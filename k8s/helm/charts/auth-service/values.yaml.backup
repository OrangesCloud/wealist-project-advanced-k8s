# =============================================================================
# auth-service - Service Configuration
# =============================================================================
# Spring Boot 3 authentication service using JWT and OAuth2
# Uses Redis only (no database)
#
# Global settings (namespace, environment, imageRegistry, domain) are defined
# in helm/environments/*.yaml files.

# -----------------------------------------------------------------------------
# Image Configuration
# -----------------------------------------------------------------------------
image:
  repository: auth-service
  # pullPolicy and tag are set in helm/environments/*.yaml

imagePullSecrets: []

# -----------------------------------------------------------------------------
# Deployment Configuration
# -----------------------------------------------------------------------------
replicaCount: 2  # Minimum 2 for high availability

# Update strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0  # Zero downtime

# -----------------------------------------------------------------------------
# Service Configuration
# -----------------------------------------------------------------------------
service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}

# -----------------------------------------------------------------------------
# Application Configuration (Service-Specific Only)
# -----------------------------------------------------------------------------
# Note: Common config (ENV, LOG_LEVEL, REDIS_HOST, REDIS_PORT, CORS_ORIGINS, etc.)
# comes from helm/environments/*.yaml via shared.config section.
# Only service-specific values should be defined here.
config:
  # Server (service-specific port)
  PORT: "8080"
  SERVER_PORT: "8080"

  # Spring Boot specific
  SPRING_PROFILES_ACTIVE: "production"

  # Redis (Spring Boot uses SPRING_REDIS_* naming convention)
  SPRING_REDIS_HOST: "redis"
  SPRING_REDIS_PORT: "6379"

  # JWT configuration (service-specific)
  JWT_EXPIRATION: "3600000"  # 1 hour in milliseconds
  JWT_REFRESH_EXPIRATION: "86400000"  # 24 hours

  # OAuth2 configuration is now centralized in helm/environments/*.yaml
  # via shared.config section. These values are environment-specific:
  # - OAUTH2_CLIENT_REDIRECT_URI: Where Google redirects after auth
  # - OAUTH2_REDIRECT_URL_ENV: Where auth-service redirects frontend
  # Do NOT define them here to avoid overriding environment values.

# -----------------------------------------------------------------------------
# External Secrets (for production credentials)
# -----------------------------------------------------------------------------
externalSecrets:
  enabled: false  # Enable in production
  secretStore: aws-secrets-manager
  secretStoreKind: ClusterSecretStore
  refreshInterval: 1h
  secrets:
    - key: auth-service/jwt-secret
      property: JWT_SECRET
    - key: auth-service/oauth2-client-id
      property: OAUTH2_CLIENT_ID
    - key: auth-service/oauth2-client-secret
      property: OAUTH2_CLIENT_SECRET
    - key: auth-service/redis-password
      property: REDIS_PASSWORD

# -----------------------------------------------------------------------------
# Health Check Configuration (Spring Boot Actuator)
# -----------------------------------------------------------------------------
# Note: Spring Boot takes longer to start than Go services.
# These values should NOT be overridden by environment files.
healthCheck:
  liveness:
    path: /actuator/health/liveness
    initialDelaySeconds: 90    # Spring Boot needs ~73s to start, give extra buffer
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5        # More retries for slow startup
  readiness:
    path: /actuator/health/readiness
    initialDelaySeconds: 75    # Wait for app to be ready
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 5

# -----------------------------------------------------------------------------
# Resource Management
# -----------------------------------------------------------------------------
resources:
  requests:
    memory: "512Mi"
    cpu: "250m"
  limits:
    memory: "1Gi"
    cpu: "1000m"

# -----------------------------------------------------------------------------
# Autoscaling Configuration
# -----------------------------------------------------------------------------
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300  # 5 minutes
      policies:
        - type: Percent
          value: 50  # Scale down max 50% of current pods
          periodSeconds: 60
        - type: Pods
          value: 1  # Or 1 pod at a time
          periodSeconds: 60
      selectPolicy: Min  # Choose the smallest change
    scaleUp:
      stabilizationWindowSeconds: 0  # Scale up immediately
      policies:
        - type: Percent
          value: 100  # Double the pods if needed
          periodSeconds: 30
        - type: Pods
          value: 2  # Or add 2 pods
          periodSeconds: 30
      selectPolicy: Max  # Choose the largest change

# -----------------------------------------------------------------------------
# Security Configuration
# -----------------------------------------------------------------------------
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false  # Spring Boot needs writable /tmp
  runAsNonRoot: true
  runAsUser: 1000

# -----------------------------------------------------------------------------
# Service Account
# -----------------------------------------------------------------------------
serviceAccount:
  create: true
  annotations: {}
  name: ""  # Auto-generated if empty
  automount: true

# -----------------------------------------------------------------------------
# Pod Disruption Budget (High Availability)
# -----------------------------------------------------------------------------
podDisruptionBudget:
  enabled: true
  minAvailable: 1  # Always keep at least 1 pod running
  # maxUnavailable: 1  # Alternative: allow max 1 pod down

# -----------------------------------------------------------------------------
# Network Policy (Optional - enable for network segmentation)
# -----------------------------------------------------------------------------
networkPolicy:
  enabled: false  # Enable in production if using network policies
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: wealist
      ports:
        - protocol: TCP
          port: 8080
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: wealist
      ports:
        - protocol: TCP
          port: 6379  # Redis only (no database)
    - to:  # DNS
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: UDP
          port: 53

# -----------------------------------------------------------------------------
# Monitoring and Metrics
# -----------------------------------------------------------------------------
metrics:
  enabled: true
  path: /actuator/prometheus
  port: 8080

podAnnotations: {}

# -----------------------------------------------------------------------------
# Node Selection and Affinity
# -----------------------------------------------------------------------------
nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - auth-service
          topologyKey: kubernetes.io/hostname

# -----------------------------------------------------------------------------
# Persistence (for Spring Boot temp files if needed)
# -----------------------------------------------------------------------------
persistence:
  enabled: false
  storageClass: ""
  accessMode: ReadWriteOnce
  size: 1Gi
  mountPath: /tmp

# -----------------------------------------------------------------------------
# Additional Configuration
# -----------------------------------------------------------------------------
extraEnv: []
# - name: CUSTOM_VAR
#   value: "custom-value"

extraEnvFrom: []
# - configMapRef:
#     name: extra-config

extraVolumes: []
extraVolumeMounts: []
